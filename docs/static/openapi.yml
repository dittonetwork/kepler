{"id":"github.com/dittonetwork/kepler","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/dittonetwork/kepler REST API","title":"HTTP API Console","contact":{"name":"github.com/dittonetwork/kepler"},"version":"version not set"},"paths":{"/cosmos/epochs/v1beta1/current_epoch":{"get":{"tags":["Query"],"summary":"CurrentEpoch provide current epoch of specified identifier","operationId":"GithubComdittonetworkkeplerQuery_CurrentEpoch","parameters":[{"type":"string","description":"identifier is the identifier of the epoch.","name":"identifier","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.epochs.QueryCurrentEpochResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmos/epochs/v1beta1/epochs":{"get":{"tags":["Query"],"summary":"EpochInfos provide running epochInfos","operationId":"GithubComdittonetworkkeplerQuery_EpochInfos","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.epochs.QueryEpochInfosResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/dittonetwork/kepler/restaking/need_update":{"get":{"tags":["Query"],"summary":"Return true if need update validators set","operationId":"GithubComdittonetworkkeplerQuery_NeedValidatorsUpdate","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.QueryNeedValidatorsUpdateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/dittonetwork/kepler/restaking/operator_status/{evm_address}":{"get":{"tags":["Query"],"summary":"Retrieve the status of a validator by its operator address.","operationId":"GithubComdittonetworkkeplerQuery_OperatorStatus","parameters":[{"type":"string","description":"evm_address is the EVM address on L1.","name":"evm_address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.QueryOperatorStatusResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/dittonetwork/kepler/restaking/v1/pending_operators":{"get":{"tags":["Query"],"summary":"PendingValidators returns currently pending validators of the module.","operationId":"GithubComdittonetworkkeplerQuery_PendingOperators","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.QueryPendingOperatorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/dittonetwork/kepler/restaking/validators":{"get":{"tags":["Query"],"summary":"Retrieve a list of all validators.","operationId":"GithubComdittonetworkkeplerQuery_Validators","parameters":[{"enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"type":"string","default":"BOND_STATUS_UNSPECIFIED","description":"status enables to query for validators matching a given status.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED indicates that the status of the validator is unknown.\n - BOND_STATUS_UNBONDED: UNBONDED indicates that the validator is in the process of bonding.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.","name":"status","in":"query"},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.QueryValidatorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler.committee.Msg/SendReport":{"post":{"tags":["Msg"],"summary":"SendReport defines a operation for sending a report to the committee.","operationId":"GithubComdittonetworkkeplerMsg_SendReport","parameters":[{"description":"MsgSendReport defines report message.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/kepler.committee.MsgSendReport"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.committee.MsgSendReportResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler.committee.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubComdittonetworkkeplerMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/kepler.committee.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.committee.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler.restaking.Msg/BondValidator":{"post":{"tags":["Msg"],"summary":"Complete the bonding process for a validator recognized in Bonding status.","operationId":"GithubComdittonetworkkeplerMsg_BondValidator","parameters":[{"description":"MsgBondValidator is the request type for the Msg/BondValidator RPC method.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/kepler.restaking.MsgBondValidator"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.MsgBondValidatorResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler.restaking.Msg/UpdateValidatorsSet":{"post":{"tags":["Msg"],"summary":"UpdateValidatorsSet is the request type for the Msg/UpdateValidatorsSet RPC method.","operationId":"GithubComdittonetworkkeplerMsg_UpdateValidatorsSet","parameters":[{"description":"MsgUpdateValidatorsSet is the request type for the Msg/UpdateValidatorsSet.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/kepler.restaking.MsgUpdateValidatorsSet"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.restaking.MsgUpdateValidatorsSetResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler/committee/committee":{"get":{"tags":["Query"],"summary":"Get current committee","operationId":"GithubComdittonetworkkeplerQuery_Committee","parameters":[{"type":"string","format":"int64","name":"epoch","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.committee.QueryCommitteeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/kepler/committee/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubComdittonetworkkeplerQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/kepler.committee.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"cosmos.base.query.v1beta1.PageRequest":{"description":"message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }","type":"object","title":"PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:","properties":{"count_total":{"description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","type":"boolean"},"key":{"description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","type":"string","format":"byte"},"limit":{"description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","type":"string","format":"uint64"},"offset":{"description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","type":"string","format":"uint64"},"reverse":{"description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","type":"boolean"}}},"cosmos.base.query.v1beta1.PageResponse":{"description":"PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }","type":"object","properties":{"next_key":{"description":"next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.","type":"string","format":"byte"},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"}}},"google.protobuf.Any":{"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }","type":"object","properties":{"@type":{"description":"A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.","type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"kepler.committee.Committee":{"description":"Committee defines a group of executors that participate in a decision-making process.","type":"object","properties":{"address":{"description":"address is the address of the committee.","type":"string"},"epoch":{"description":"epoch is the epoch of the committee.","type":"string","format":"int64"},"executors":{"description":"executors is the list of participants in this committee.","type":"array","items":{"type":"object","$ref":"#/definitions/kepler.committee.Executor"}},"is_emergency":{"description":"is_emergency indicates whether this committee was formed for an emergency situation.","type":"boolean"},"seed":{"description":"seed is the seed of the committee. Needed for randomness.","type":"string","format":"byte"}}},"kepler.committee.Executor":{"description":"Executor represents a committee member with voting capabilities.","type":"object","properties":{"address":{"description":"address is the account address of the executor.","type":"string"},"pubkey":{"description":"pubkey is the public key of the executor.","$ref":"#/definitions/google.protobuf.Any"},"voting_power":{"description":"voting_power represents the weight of this executor's vote in committee decisions.","type":"string","format":"int64"}}},"kepler.committee.MsgSendReport":{"description":"MsgSendReport defines report message.","type":"object","properties":{"creator":{"description":"creator is the address of the creator of the report.","type":"string"},"epoch_id":{"description":"epoch_id is the id of the epoch that the report is for.","type":"string","format":"int64"},"report":{"description":"report is the report that is being sent.","$ref":"#/definitions/kepler.committee.Report"}}},"kepler.committee.MsgSendReportResponse":{"description":"MsgSendReportResponse is the response to a MsgSendReport message.","type":"object"},"kepler.committee.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/kepler.committee.Params"}}},"kepler.committee.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"kepler.committee.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"max_committee_size":{"description":"max_committee_size is the max number of members in a committee.","type":"integer","format":"int64"},"min_committee_size":{"description":"min_committee_size is the min number of members in a committee.","type":"integer","format":"int64"},"randao_enabled":{"description":"randao_enabled is a flag to enable/disable the RANDAO.","type":"boolean"}}},"kepler.committee.QueryCommitteeResponse":{"description":"QueryCommitteeResponse is response type for the Query/Committee RPC method.","type":"object","properties":{"committee":{"$ref":"#/definitions/kepler.committee.Committee"}}},"kepler.committee.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/kepler.committee.Params"}}},"kepler.committee.Report":{"description":"Report is a message that contains a report from the committee.","type":"object","properties":{"committee_id":{"description":"committee_id is the id of the committee that the report is for.","type":"string"},"execution_context":{"description":"execution_context is the context of the execution of the report.","$ref":"#/definitions/google.protobuf.Any"},"messages":{"description":"messages are the messages that are being reported.","type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"kepler.epochs.EpochInfo":{"description":"EpochInfo is a struct that describes the data going into\na timer defined by the x/epochs module.","type":"object","properties":{"current_epoch":{"description":"current_epoch is the current epoch number, or in other words,\nhow many times has the timer 'ticked'.\nThe first tick (current_epoch=1) is defined as\nthe first block whose blocktime is greater than the EpochInfo start_time.","type":"string","format":"int64"},"current_epoch_start_height":{"type":"string","format":"int64","title":"current_epoch_start_height is the block height at which the current epoch\nstarted. (The block height at which the timer last ticked)"},"current_epoch_start_time":{"description":"current_epoch_start_time describes the start time of the current timer\ninterval. The interval is (current_epoch_start_time,\ncurrent_epoch_start_time + duration] When the timer ticks, this is set to\ncurrent_epoch_start_time = last_epoch_start_time + duration only one timer\ntick for a given identifier can occur per block.\n\nNOTE! The current_epoch_start_time may diverge significantly from the\nwall-clock time the epoch began at. Wall-clock time of epoch start may be\n\u003e\u003e current_epoch_start_time. Suppose current_epoch_start_time = 10,\nduration = 5. Suppose the chain goes offline at t=14, and comes back online\nat t=30, and produces blocks at every successive time. (t=31, 32, etc.)\n* The t=30 block will start the epoch for (10, 15]\n* The t=31 block will start the epoch for (15, 20]\n* The t=32 block will start the epoch for (20, 25]\n* The t=33 block will start the epoch for (25, 30]\n* The t=34 block will start the epoch for (30, 35]\n* The **t=36** block will start the epoch for (35, 40]","type":"string","format":"date-time"},"duration":{"description":"duration is the time in between epoch ticks.\nIn order for intended behavior to be met, duration should\nbe greater than the chains expected block time.\nDuration must be non-zero.","type":"string"},"epoch_counting_started":{"description":"epoch_counting_started is a boolean, that indicates whether this\nepoch timer has began yet.","type":"boolean"},"identifier":{"description":"identifier is the unique identifier of the epoch.","type":"string"},"start_time":{"description":"start_time is the time at which the timer first ever ticks.\nIf start_time is in the future, the epoch will not begin until the start\ntime.","type":"string","format":"date-time"}}},"kepler.epochs.QueryCurrentEpochResponse":{"description":"QueryCurrentEpochResponse is response type for the Query/CurrentEpoch RPC method.\nquerying an epoch by its identifier.","type":"object","properties":{"current_epoch":{"description":"current_epoch holds the current epoch of this module.","type":"string","format":"int64"}}},"kepler.epochs.QueryEpochInfosResponse":{"description":"QueryEpochInfosResponse is response type for the Query/Epochs RPC method.\nquerying all epoch info.","type":"object","properties":{"epochs":{"description":"epochs holds all the epochInfos of this module.","type":"array","items":{"type":"object","$ref":"#/definitions/kepler.epochs.EpochInfo"}}}},"kepler.restaking.BondStatus":{"description":"- BOND_STATUS_UNSPECIFIED: UNSPECIFIED indicates that the status of the validator is unknown.\n - BOND_STATUS_UNBONDED: UNBONDED indicates that the validator is in the process of bonding.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.","type":"string","title":"BondStatus is the status of a validator","default":"BOND_STATUS_UNSPECIFIED","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"]},"kepler.restaking.Description":{"description":"Description defines a validator description.","type":"object","properties":{"details":{"description":"details define other optional details.","type":"string"},"identity":{"description":"identity defines an optional identity signature (ex. UPort or Keybase).","type":"string"},"moniker":{"description":"moniker defines a human-readable name for the validator.","type":"string"},"security_contact":{"description":"security_contact defines an optional email for security contact.","type":"string"},"website":{"description":"website defines an optional website link.","type":"string"}}},"kepler.restaking.MsgBondValidator":{"description":"MsgBondValidator is the request type for the Msg/BondValidator RPC method.","type":"object","properties":{"description":{"$ref":"#/definitions/kepler.restaking.Description"},"owner":{"description":"owner is the address of the validator operator.","type":"string"}}},"kepler.restaking.MsgBondValidatorResponse":{"description":"MsgBondValidatorResponse is the response type for the Msg/BondValidator.","type":"object"},"kepler.restaking.MsgUpdateValidatorsSet":{"description":"MsgUpdateValidatorsSet is the request type for the Msg/UpdateValidatorsSet.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/committee unless overwritten).","type":"string"},"info":{"description":"info contains information about the last update.","$ref":"#/definitions/kepler.restaking.UpdateInfo"},"operators":{"description":"operators is the list of operators to update.","type":"array","items":{"type":"object","$ref":"#/definitions/kepler.restaking.Operator"}}}},"kepler.restaking.MsgUpdateValidatorsSetResponse":{"description":"MsgUpdateValidatorsSetResponse is the response type for the Msg/UpdateValidatorsSet.","type":"object"},"kepler.restaking.Operator":{"description":"Operator is a message that contains information about a validator operator.","type":"object","properties":{"address":{"description":"address is the Ethereum-style address (hex-encoded, 0x-prefixed) derived from\nthe last 20 bytes of the keccak256 hash of the operator's public key.\nThis address need for binding updates with bond.","type":"string"},"consensus_pubkey":{"description":"consensus_pubkey is the consensus ed25519 public key of the validator, as a\nProtobuf Any.","$ref":"#/definitions/google.protobuf.Any"},"is_emergency":{"type":"boolean","title":"is_emergency defines whether the validator is an emergency validator"},"protocol":{"title":"protocol is the protocol of the restaking module","$ref":"#/definitions/kepler.restaking.Protocol"},"status":{"title":"status defines the validator's status (bonded/unbonding/unbonded)","$ref":"#/definitions/kepler.restaking.BondStatus"},"voting_power":{"type":"string","format":"int64","title":"voting_power is the voting power of the validator"}}},"kepler.restaking.Protocol":{"description":"- PROTOCOL_UNSPECIFIED: UNSPECIFIED indicates that the protocol is unknown.\n - PROTOCOL_DITTO: DITTO defines the protocol for Ditto.\n - PROTOCOL_SYMBIOTIC: SYMBIOTIC defines the protocol for Symbiotic.\n - PROTOCOL_EIGENLAYER: EIGENLAYER defines the protocol for EigenLayer.","type":"string","title":"Protocol is the protocol of the restaking module","default":"PROTOCOL_UNSPECIFIED","enum":["PROTOCOL_UNSPECIFIED","PROTOCOL_DITTO","PROTOCOL_SYMBIOTIC","PROTOCOL_EIGENLAYER"]},"kepler.restaking.QueryNeedValidatorsUpdateResponse":{"description":"QueryNeedValidatorsUpdateResponse returns bool result.","type":"object","properties":{"result":{"type":"boolean"}}},"kepler.restaking.QueryOperatorStatusResponse":{"description":"QueryValidatorStatusResponse is the response type for the Query/ValidatorStatus RPC method.","type":"object","properties":{"info":{"title":"operator info","$ref":"#/definitions/kepler.restaking.Operator"},"status":{"description":"status is the status of the validator.","$ref":"#/definitions/kepler.restaking.QueryOperatorStatusResponse.Status"}}},"kepler.restaking.QueryOperatorStatusResponse.Status":{"description":"status of the validator.\n\n - STATUS_UNSPECIFIED: UnspecifiedStatus is the default status.\n - STATUS_ACTIVE: ActiveStatus - validator is active and participate in chain.\n - STATUS_PENDING: PendingStatus - validator is pending and waiting for BondValidator tx.\n - STATUS_INACTIVE: InactiveStatus - validator is inactive and not participate in chain.","type":"string","default":"STATUS_UNSPECIFIED","enum":["STATUS_UNSPECIFIED","STATUS_ACTIVE","STATUS_PENDING","STATUS_INACTIVE"]},"kepler.restaking.QueryPendingOperatorsResponse":{"description":"QueryPendingValidatorsResponse is the response type for the Query/PendingValidators RPC method.","type":"object","properties":{"pending":{"description":"Pending is the returned pending validators from the module.","type":"array","items":{"type":"object","$ref":"#/definitions/kepler.restaking.Operator"}}}},"kepler.restaking.QueryValidatorsResponse":{"description":"QueryValidatorsResponse is the response type for the Query/Validators RPC method.","type":"object","properties":{"pagination":{"description":"pagination defines an optional pagination for the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"},"validators":{"description":"validators is a list of validators.","type":"array","items":{"type":"object","$ref":"#/definitions/kepler.restaking.Validator"}}}},"kepler.restaking.UpdateInfo":{"description":"UpdateInfo is a collection of update information from L1.","type":"object","properties":{"block_hash":{"type":"string","title":"block_hash is the block hash on L1 of the last update"},"block_height":{"type":"string","format":"int64","title":"block_height is the block height on L1 of the last update"},"epoch_num":{"type":"string","format":"int64","title":"epoch_num is the epoch number of the update"},"timestamp":{"type":"string","format":"date-time","title":"timestamp of the last update"}}},"kepler.restaking.Validator":{"description":"Validator defines a validator in the restaking module.","type":"object","properties":{"consensus_pubkey":{"description":"consensus_pubkey is the consensus ed25519 public key of the validator, as a\nProtobuf Any.","$ref":"#/definitions/google.protobuf.Any"},"description":{"$ref":"#/definitions/kepler.restaking.Description"},"evm_operator_address":{"description":"evm_operator_address is the Ethereum-style address (hex-encoded, 0x-prefixed) derived from\nthe last 20 bytes of the keccak256 hash of the operator's public key.\nThis address need for binding updates with bond.","type":"string"},"is_emergency":{"type":"boolean","title":"is_emergency defines whether the validator is an emergency validator"},"operator_address":{"description":"operator_address is account address in Bech32 format.\nthe same as the operator address but diff algorithm generation.","type":"string"},"protocol":{"title":"protocol is the protocol of the restaking module","$ref":"#/definitions/kepler.restaking.Protocol"},"status":{"title":"status defines the validator's status (bonded/unbonding/unbonded)","$ref":"#/definitions/kepler.restaking.BondStatus"},"voting_power":{"type":"string","format":"int64","title":"voting_power is the voting power of the validator"}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}